<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>W-System Quantum Computing - Level 3: Quantum Error Correction</title>
    <link href="https://fonts.googleapis.com/css2?family=Overpass:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --secondary-bg: #0F282D;
            --main-bg: #183948;
            --menu-bar: #09181F;
            --secondary: #166470;
            --accent: #3EC1C9;
            --text-overlay-bg: rgba(15, 40, 45, 0.8);
            --menu-gradient: linear-gradient(90deg, #0F282D 0%, rgba(15, 40, 45, 0.8) 100%);
            --photon-color: #FFC78E;
            --photon-button: #FFB163;
            --entanglement: #FF6B9D;
            --error-color: #FF4444;
            --success-color: #44FF44;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Overpass', sans-serif;
            background: var(--main-bg);
            color: white;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        .header {
            background: var(--menu-bar);
            padding: 1rem 2rem;
            border-bottom: 2px solid var(--secondary);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent);
        }

        .header p {
            font-size: 0.9rem;
            color: #ccc;
            margin-top: 0.25rem;
        }

        .nav-button {
            background: var(--secondary);
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            color: white;
            font-family: 'Overpass', sans-serif;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .nav-button:hover {
            background: var(--accent);
            transform: translateY(-2px);
        }

        /* Main Container */
        .main-container {
            display: flex;
            gap: 2rem;
            padding: 2rem;
            flex: 1;
        }

        /* Visualization Area */
        .visualization-area {
            flex: 2.5;
            background: var(--secondary-bg);
            border-radius: 12px;
            border: 1px solid var(--secondary);
            padding: 2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }

        /* Surface Code Lattice */
        #surface-code-container {
            width: 600px;
            height: 500px;
            position: relative;
            margin: 2rem 0;
        }

        .qubit-node {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 0.8rem;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .data-qubit {
            background: var(--secondary);
            border: 2px solid var(--accent);
        }

        .ancilla-qubit {
            background: var(--menu-bar);
            border: 2px solid #666;
            transform: rotate(45deg);
        }

        .ancilla-qubit span {
            transform: rotate(-45deg);
        }

        .qubit-node.error-x {
            background: var(--error-color);
            animation: errorPulse 1s ease-in-out;
        }

        .qubit-node.error-z {
            border-color: var(--error-color);
            border-width: 4px;
            animation: errorPulse 1s ease-in-out;
        }

        .qubit-node.syndrome-active {
            background: var(--photon-color);
            box-shadow: 0 0 20px rgba(255, 199, 142, 0.6);
        }

        @keyframes errorPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        .stabilizer-line {
            position: absolute;
            background: var(--secondary);
            opacity: 0.3;
            transition: all 0.3s ease;
        }

        .stabilizer-line.active {
            background: var(--accent);
            opacity: 0.8;
        }

        /* Control Panel */
        .control-panel {
            flex: 1;
            background: var(--secondary-bg);
            border-radius: 12px;
            border: 1px solid var(--secondary);
            padding: 2rem;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .control-section {
            background: var(--text-overlay-bg);
            border-radius: 8px;
            padding: 1rem;
        }

        .control-section h3 {
            color: var(--accent);
            margin-bottom: 1rem;
            font-size: 1rem;
        }

        .error-buttons {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .error-button {
            background: var(--secondary);
            border: none;
            padding: 0.75rem 1rem;
            border-radius: 8px;
            color: white;
            font-family: 'Overpass', sans-serif;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            text-align: left;
        }

        .error-button:hover {
            background: var(--error-color);
            transform: translateX(5px);
        }

        .primary-button {
            background: var(--secondary);
            border: none;
            padding: 1rem 2rem;
            border-radius: 8px;
            color: white;
            font-family: 'Overpass', sans-serif;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            font-size: 1rem;
        }

        .primary-button:hover:not(:disabled) {
            background: var(--accent);
            transform: translateY(-2px);
        }

        .primary-button:disabled {
            background: #666;
            cursor: not-allowed;
        }

        /* Status Display */
        .status-display {
            background: var(--text-overlay-bg);
            border-radius: 8px;
            padding: 1rem;
            border-left: 4px solid var(--accent);
        }

        .status-display h4 {
            color: var(--accent);
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }

        .status-display p {
            color: #ccc;
            font-size: 0.85rem;
            line-height: 1.4;
        }

        .error-rate-display {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-top: 1rem;
        }

        .rate-box {
            background: var(--menu-bar);
            padding: 0.75rem;
            border-radius: 6px;
            text-align: center;
        }

        .rate-box .label {
            font-size: 0.75rem;
            color: #999;
            margin-bottom: 0.25rem;
        }

        .rate-box .value {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--accent);
        }

        /* Instruction text */
        .instruction-text {
            background: var(--menu-gradient);
            border-radius: 8px;
            padding: 1rem;
            text-align: center;
            margin-bottom: 1rem;
        }

        .instruction-text p {
            color: #ccc;
            font-size: 0.9rem;
        }

        /* Legend */
        .legend {
            display: flex;
            gap: 2rem;
            margin-top: 1rem;
            justify-content: center;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
            color: #ccc;
        }

        .legend-symbol {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid transparent;
        }

        .legend-symbol.data {
            background: var(--secondary);
            border-color: var(--accent);
        }

        .legend-symbol.ancilla {
            background: var(--menu-bar);
            border-color: #666;
            transform: rotate(45deg);
        }

        .legend-symbol.error-x {
            background: var(--error-color);
        }

        .legend-symbol.error-z {
            background: transparent;
            border-color: var(--error-color);
            border-width: 4px;
        }
    </style>
</head>
<body>
    <header class="header">
        <div>
            <h1>Level 3: Quantum Error Correction</h1>
            <p>Learn how surface codes protect quantum information</p>
        </div>
        <div style="display: flex; gap: 1rem;">
            <button class="nav-button" onclick="window.location.href='lvl2.html'">← Level 2</button>
            <button class="nav-button" onclick="window.location.href='index.html'">Back to Menu</button>
        </div>
    </header>

    <main class="main-container">
        <div class="visualization-area">
            <div class="instruction-text">
                <p>Click on data qubits to inject errors • Watch syndrome measurements detect errors • See how the surface code corrects errors</p>
            </div>
            
            <div id="surface-code-container"></div>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-symbol data"></div>
                    <span>Data Qubit</span>
                </div>
                <div class="legend-item">
                    <div class="legend-symbol ancilla"></div>
                    <span>Ancilla Qubit</span>
                </div>
                <div class="legend-item">
                    <div class="legend-symbol error-x"></div>
                    <span>X Error (Bit Flip)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-symbol error-z"></div>
                    <span>Z Error (Phase Flip)</span>
                </div>
            </div>
        </div>

        <div class="control-panel">
            <div class="control-section">
                <h3>Error Injection</h3>
                <div class="error-buttons">
                    <button class="error-button" onclick="setErrorMode('X')">
                        X Error (Bit Flip) - Click qubits
                    </button>
                    <button class="error-button" onclick="setErrorMode('Z')">
                        Z Error (Phase Flip) - Click qubits
                    </button>
                    <button class="error-button" onclick="injectRandomError()">
                        Random Error
                    </button>
                </div>
            </div>

            <button class="primary-button" onclick="measureSyndromes()">
                Measure Syndromes
            </button>

            <button class="primary-button" onclick="applyCorrection()" id="correctButton" disabled>
                Apply Correction
            </button>

            <button class="primary-button" onclick="resetLattice()">
                Reset Lattice
            </button>

            <div class="status-display">
                <h4>System Status</h4>
                <p id="statusText">Ready - Click on qubits to inject errors</p>
                
                <div class="error-rate-display">
                    <div class="rate-box">
                        <div class="label">Physical Errors</div>
                        <div class="value" id="physicalErrors">0</div>
                    </div>
                    <div class="rate-box">
                        <div class="label">Logical Errors</div>
                        <div class="value" id="logicalErrors">0</div>
                    </div>
                </div>
            </div>

            <div class="status-display">
                <h4>About Surface Codes</h4>
                <p>Surface codes use a 2D lattice of qubits where data qubits store information and ancilla qubits detect errors. By measuring stabilizers (patterns of neighboring qubits), we can detect and correct errors without destroying the quantum information.</p>
            </div>
        </div>
    </main>

    <script>
        // Surface code lattice configuration
        const LATTICE_SIZE = 5; // 5x5 lattice
        const QUBIT_SPACING = 100;
        const OFFSET = 50;
        
        let errorMode = null;
        let latticeState = {};
        let syndromeResults = {};
        let physicalErrorCount = 0;
        let logicalErrorCount = 0;
        let correctionAttempts = 0;

        // Initialize the surface code lattice
        function initializeLattice() {
            const container = document.getElementById('surface-code-container');
            container.innerHTML = '';
            
            // Create stabilizer lines first (background)
            createStabilizerLines(container);
            
            // Create qubits
            for (let row = 0; row < LATTICE_SIZE; row++) {
                for (let col = 0; col < LATTICE_SIZE; col++) {
                    const isDataQubit = (row + col) % 2 === 0;
                    const qubitId = `q_${row}_${col}`;
                    
                    const qubit = document.createElement('div');
                    qubit.className = `qubit-node ${isDataQubit ? 'data-qubit' : 'ancilla-qubit'}`;
                    qubit.id = qubitId;
                    qubit.style.left = `${OFFSET + col * QUBIT_SPACING}px`;
                    qubit.style.top = `${OFFSET + row * QUBIT_SPACING}px`;
                    
                    const label = document.createElement('span');
                    label.textContent = isDataQubit ? 'D' : 'A';
                    qubit.appendChild(label);
                    
                    if (isDataQubit) {
                        qubit.onclick = () => toggleError(row, col);
                    }
                    
                    container.appendChild(qubit);
                    
                    // Initialize state
                    latticeState[qubitId] = {
                        row: row,
                        col: col,
                        isData: isDataQubit,
                        errorX: false,
                        errorZ: false
                    };
                }
            }
        }

        // Create stabilizer visualization lines
        function createStabilizerLines(container) {
            // Create horizontal and vertical stabilizer indicators
            for (let row = 0; row < LATTICE_SIZE; row++) {
                for (let col = 0; col < LATTICE_SIZE; col++) {
                    if ((row + col) % 2 === 1) { // Ancilla positions
                        // Create cross pattern for stabilizers
                        const hLine = document.createElement('div');
                        hLine.className = 'stabilizer-line';
                        hLine.style.width = `${QUBIT_SPACING * 2}px`;
                        hLine.style.height = '2px';
                        hLine.style.left = `${OFFSET + (col - 1) * QUBIT_SPACING + 20}px`;
                        hLine.style.top = `${OFFSET + row * QUBIT_SPACING + 19}px`;
                        hLine.id = `stab_h_${row}_${col}`;
                        container.appendChild(hLine);
                        
                        const vLine = document.createElement('div');
                        vLine.className = 'stabilizer-line';
                        vLine.style.width = '2px';
                        vLine.style.height = `${QUBIT_SPACING * 2}px`;
                        vLine.style.left = `${OFFSET + col * QUBIT_SPACING + 19}px`;
                        vLine.style.top = `${OFFSET + (row - 1) * QUBIT_SPACING + 20}px`;
                        vLine.id = `stab_v_${row}_${col}`;
                        container.appendChild(vLine);
                    }
                }
            }
        }

        // Set the current error injection mode
        function setErrorMode(mode) {
            errorMode = mode;
            updateStatus(`${mode} error mode active - Click data qubits to inject errors`);
        }

        // Toggle error on a qubit
        function toggleError(row, col) {
            if (!errorMode) {
                updateStatus('Please select an error type first');
                return;
            }
            
            const qubitId = `q_${row}_${col}`;
            const qubit = document.getElementById(qubitId);
            const state = latticeState[qubitId];
            
            if (!state.isData) return;
            
            if (errorMode === 'X') {
                state.errorX = !state.errorX;
                if (state.errorX) {
                    qubit.classList.add('error-x');
                    physicalErrorCount++;
                } else {
                    qubit.classList.remove('error-x');
                    physicalErrorCount = Math.max(0, physicalErrorCount - 1);
                }
            } else if (errorMode === 'Z') {
                state.errorZ = !state.errorZ;
                if (state.errorZ) {
                    qubit.classList.add('error-z');
                    physicalErrorCount++;
                } else {
                    qubit.classList.remove('error-z');
                    physicalErrorCount = Math.max(0, physicalErrorCount - 1);
                }
            }
            
            updateErrorDisplay();
            updateStatus('Error injected - Measure syndromes to detect');
            document.getElementById('correctButton').disabled = true;
        }

        // Inject random error
        function injectRandomError() {
            const dataQubits = Object.keys(latticeState).filter(id => latticeState[id].isData);
            const randomQubit = dataQubits[Math.floor(Math.random() * dataQubits.length)];
            const state = latticeState[randomQubit];
            
            errorMode = Math.random() < 0.5 ? 'X' : 'Z';
            toggleError(state.row, state.col);
        }

        // Measure syndrome (ancilla qubits)
        function measureSyndromes() {
            syndromeResults = {};
            let syndromeDetected = false;
            
            // Clear previous syndrome highlights
            document.querySelectorAll('.ancilla-qubit').forEach(q => {
                q.classList.remove('syndrome-active');
            });
            document.querySelectorAll('.stabilizer-line').forEach(l => {
                l.classList.remove('active');
            });
            
            // Check each ancilla qubit
            for (let row = 0; row < LATTICE_SIZE; row++) {
                for (let col = 0; col < LATTICE_SIZE; col++) {
                    if ((row + col) % 2 === 1) { // Ancilla qubit
                        const ancillaId = `q_${row}_${col}`;
                        let xParity = 0;
                        let zParity = 0;
                        
                        // Check neighboring data qubits
                        const neighbors = [
                            [row - 1, col], [row + 1, col],
                            [row, col - 1], [row, col + 1]
                        ];
                        
                        neighbors.forEach(([r, c]) => {
                            if (r >= 0 && r < LATTICE_SIZE && c >= 0 && c < LATTICE_SIZE) {
                                const neighborId = `q_${r}_${c}`;
                                const neighborState = latticeState[neighborId];
                                if (neighborState && neighborState.isData) {
                                    if (neighborState.errorX) xParity ^= 1;
                                    if (neighborState.errorZ) zParity ^= 1;
                                }
                            }
                        });
                        
                        syndromeResults[ancillaId] = { xParity, zParity };
                        
                        // Highlight active syndromes
                        if (xParity || zParity) {
                            syndromeDetected = true;
                            document.getElementById(ancillaId).classList.add('syndrome-active');
                            
                            // Highlight stabilizer lines
                            const hLine = document.getElementById(`stab_h_${row}_${col}`);
                            const vLine = document.getElementById(`stab_v_${row}_${col}`);
                            if (hLine) hLine.classList.add('active');
                            if (vLine) vLine.classList.add('active');
                        }
                    }
                }
            }
            
            if (syndromeDetected) {
                updateStatus('Syndromes detected! Errors found - Apply correction');
                document.getElementById('correctButton').disabled = false;
            } else if (physicalErrorCount > 0) {
                updateStatus('No syndromes detected - Undetectable error pattern!');
                logicalErrorCount++;
                updateErrorDisplay();
            } else {
                updateStatus('No syndromes detected - System is error-free');
            }
        }

        // Apply error correction based on syndrome measurements
        function applyCorrection() {
            correctionAttempts++;
            let correctionSuccess = true;
            
            // Simple correction strategy - fix errors based on syndrome pattern
            // In a real surface code, this would use minimum weight perfect matching
            
            Object.keys(syndromeResults).forEach(ancillaId => {
                const syndrome = syndromeResults[ancillaId];
                const ancillaState = latticeState[ancillaId];
                
                if (syndrome.xParity || syndrome.zParity) {
                    // Find neighboring data qubits with errors
                    const neighbors = [
                        [ancillaState.row - 1, ancillaState.col],
                        [ancillaState.row + 1, ancillaState.col],
                        [ancillaState.row, ancillaState.col - 1],
                        [ancillaState.row, ancillaState.col + 1]
                    ];
                    
                    neighbors.forEach(([r, c]) => {
                        if (r >= 0 && r < LATTICE_SIZE && c >= 0 && c < LATTICE_SIZE) {
                            const neighborId = `q_${r}_${c}`;
                            const neighborState = latticeState[neighborId];
                            
                            if (neighborState && neighborState.isData) {
                                const qubit = document.getElementById(neighborId);
                                
                                if (syndrome.xParity && neighborState.errorX) {
                                    neighborState.errorX = false;
                                    qubit.classList.remove('error-x');
                                    physicalErrorCount = Math.max(0, physicalErrorCount - 1);
                                }
                                if (syndrome.zParity && neighborState.errorZ) {
                                    neighborState.errorZ = false;
                                    qubit.classList.remove('error-z');
                                    physicalErrorCount = Math.max(0, physicalErrorCount - 1);
                                }
                            }
                        }
                    });
                }
            });
            
            // Clear syndrome highlights
            document.querySelectorAll('.syndrome-active').forEach(q => {
                q.classList.remove('syndrome-active');
            });
            document.querySelectorAll('.stabilizer-line.active').forEach(l => {
                l.classList.remove('active');
            });
            
            updateErrorDisplay();
            
            if (physicalErrorCount === 0) {
                updateStatus('✓ Error correction successful! All errors fixed');
            } else {
                updateStatus('⚠ Partial correction - Some errors remain');
                logicalErrorCount++;
            }
            
            document.getElementById('correctButton').disabled = true;
        }

        // Reset the lattice
        function resetLattice() {
            initializeLattice();
            physicalErrorCount = 0;
            logicalErrorCount = 0;
            correctionAttempts = 0;
            errorMode = null;
            syndromeResults = {};
            updateErrorDisplay();
            updateStatus('Lattice reset - Ready for new errors');
            document.getElementById('correctButton').disabled = true;
        }

        // Update status display
        function updateStatus(message) {
            document.getElementById('statusText').textContent = message;
        }

        // Update error count display
        function updateErrorDisplay() {
            document.getElementById('physicalErrors').textContent = physicalErrorCount;
            document.getElementById('logicalErrors').textContent = logicalErrorCount;
        }

        // Initialize on load
        window.onload = () => {
            initializeLattice();
            updateErrorDisplay();
        };
    </script>
</body>
</html>